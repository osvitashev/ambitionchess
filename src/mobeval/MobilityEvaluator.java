package mobeval;

import basicseeval.BroadStaticExchangeEvaluator;
import gamestate.Bitboard;
import gamestate.Gamestate;
import gamestate.GlobalConstants.PieceType;
import gamestate.GlobalConstants.Player;
import gamestate.GlobalConstants.Square;

public class MobilityEvaluator {
	private final Gamestate game;
	private final BroadStaticExchangeEvaluator seeval;

	public MobilityEvaluator(Gamestate g, BroadStaticExchangeEvaluator see) {
		game = g;
		seeval=see;
	}

	/**
	 * should be called any time internal game state changes
	 * assumes that seeval has been initialized!
	 * todo: how to enforce that? -> would be easier once Gamestate has a zobrist code implemented.
	 */
	void initialize() {
		{// initialize blockaded pawns
			long allPawns = game.getPieces(PieceType.PAWN);
			output_blockadedPawns[Player.WHITE] = game.getPieces(Player.WHITE, PieceType.PAWN) & Bitboard.shiftSouth(allPawns);
			output_blockadedPawns[Player.BLACK] = game.getPieces(Player.BLACK, PieceType.PAWN) & Bitboard.shiftNorth(allPawns);
		}
	}

	/**
	 * a pawn blocked by another pawn in front of it (whether ours' or opponents')
	 */
	private long output_blockadedPawns[] = new long[2];

	/**
	 * pawns where forward movement is blocked by another pawn (friend or foe). Only
	 * checks single pushes.
	 * 
	 * @param player
	 * @return
	 */
	long get_output_blockadedPawns(int player) {
		assert Player.validate(player);
		return output_blockadedPawns[player];
	}

	long calculateNoGoSquares(int player, int pieceType) {
		assert Player.validate(player);
		assert PieceType.validate(pieceType);
		assert pieceType != PieceType.PAWN;//might implement as a special case later...
		
		long ret = 0;
		
		if(pieceType == PieceType.KNIGHT) {
			
			long emptySquares = game.getEmpty();
			long squaresAttackedBy_pawmKnightBishop =0;
			long squares_NOT_AttackedBy_rookQueenKing = 0;
			
			
			long squaresAttackedBy_rookQueenKing_withRecaptureAvailable =0;
			
			
			
			
			
		}
		
		/**
		 * performs a crude form of SEE. It's ok for this to be somewhat inaccurate
		 * 
		 * Although having an accurate evaluation for first step could be very useful...
		 * 
		 * Should this depend on SEEValuator?
		 * 
		 * This mightbe ok, because we will want to run SEEValuator first anyways (At least the initialize part).
		 * It is not much use to be considering mobility of there are hanging pieces on the board!!!!!! 
		 * on the other hand, evaluating capture SEE does not help here - mobility is for quiet moves!!!
		 * ->>no, even the info generated by seeval.initialize() is going to be useful here!
		 * 
		 * BUT, if there are different feature evaluators which all require each other, how to ensure that we only are calling 
		 * their initialize() methods once per position evaluation???
		 * 
		 * A break-even exchange is considered a no-go.
		 */

		return ret;
	}

}
