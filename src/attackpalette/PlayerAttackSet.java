package attackpalette;

import gamestate.Bitboard;
import gamestate.BitboardGen;
import gamestate.Board;
import gamestate.DebugLibrary;
import gamestate.GlobalConstants.PieceType;
import gamestate.GlobalConstants.Player;

public class PlayerAttackSet {
	private long[] bbdata = new long[30];// bitboards of various attacks;

	public static class SetType {
		// integer values correspond to indexes of bbdata array;
		/**
		 * For R, N, B,Q types Type1 is non-empty iff Type0 is populated. If both types
		 * are populated, Type0 is generated by the piece with LARGER square origin.
		 * This is a side effect of the way bit iteration works
		 */
		final static int PawnSetEast = 0;// east
		final static int PawnSetWest = 1;// west

		final static int KnightSet0 = 2;
		final static int KnightSet1 = 3;
		// considering up to 3 friendly pieces in a stack. B-Q-Q-P is not considered as
		// too unlikely.
		final static int BishopSet0 = 4;
		final static int BishopPawnSet0 = 5;
		final static int BishopQueenSet0 = 6;
		final static int BishopQueenPawnSet0 = 7;
		final static int BishopQueenQueenSet0 = 8;

		final static int BishopSet1 = 9;
		final static int BishopPawnSet1 = 10;
		final static int BishopQueenSet1 = 11;
		final static int BishopQueenPawnSet1 = 12;
		final static int BishopQueenQueenSet1 = 13;

		final static int KingSet = 29;

		final static int[] SET_TYPES = { PawnSetEast, PawnSetWest, KnightSet0, KnightSet1, BishopSet0, BishopPawnSet0, BishopQueenSet0, BishopQueenPawnSet0, BishopQueenQueenSet0, BishopSet1,
				BishopPawnSet1, BishopQueenSet1, BishopQueenPawnSet1, BishopQueenQueenSet1, KingSet };
	}

	public long get(int type) {
		DebugLibrary.validateValueInRange(type, SetType.SET_TYPES);
		return bbdata[type];
	}

	public void set(int type, long val) {
		DebugLibrary.validateValueInRange(type, SetType.SET_TYPES);
		bbdata[type] = val;
	}

	private long augmentWithPawnAttacks(Board brd, int player, long currentAttackSet, int sqOrigin) {
		long attackedPawns = currentAttackSet & brd.getPieces(player, PieceType.PAWN);
		long attackedPawnAttackSet;
		{// pawns
			if (player == Player.WHITE)
				attackedPawnAttackSet = Bitboard.shiftEast(Bitboard.shiftNorth(attackedPawns)) | Bitboard.shiftWest(Bitboard.shiftNorth(attackedPawns));
			else
				attackedPawnAttackSet = Bitboard.shiftEast(Bitboard.shiftSouth(attackedPawns)) | Bitboard.shiftSouth(Bitboard.shiftNorth(attackedPawns));
		}
		long newAttackSet = BitboardGen.getBishopSetEmptyBoard(sqOrigin) & attackedPawnAttackSet & ~currentAttackSet;
		return newAttackSet;
	}

	public void initialize(Board brd, int player) {
		DebugLibrary.validatePlayer(player);

		for (int i = 0; i < bbdata.length; ++i)
			bbdata[i] = 0L;
		// OPTIMIZE: use denorm king position
		set(SetType.KingSet, BitboardGen.getKingSet(Bitboard.getLowSquareIndex(brd.getPieces(player, PieceType.KING))));
		{// pawns
			long pawns = brd.getPieces(player, PieceType.PAWN);
			if (player == Player.WHITE) {
				set(SetType.PawnSetEast, Bitboard.shiftEast(Bitboard.shiftNorth(pawns)));
				set(SetType.PawnSetWest, Bitboard.shiftWest(Bitboard.shiftNorth(pawns)));
			} else {
				set(SetType.PawnSetEast, Bitboard.shiftEast(Bitboard.shiftSouth(pawns)));
				set(SetType.PawnSetWest, Bitboard.shiftWest(Bitboard.shiftSouth(pawns)));
			}
		}

		{// knights
			int bi = 0;
			int numOfType = 0;
			for (long zarg = brd.getPieces(player, PieceType.KNIGHT), barg = Bitboard.isolateLsb(zarg); zarg != 0L; zarg = Bitboard.extractLsb(zarg), barg = Bitboard.isolateLsb(zarg)) {// iterateOnBitIndices
				bi = Bitboard.getLowSquareIndex(barg);
				if (numOfType == 0) {
					set(SetType.KnightSet0, BitboardGen.getKnightSet(bi));
					numOfType++;
				} else {
					set(SetType.KnightSet1, get(SetType.KnightSet0));
					set(SetType.KnightSet0, BitboardGen.getKnightSet(bi));
					break;
				}
			}
		}

		{// bishops
			int bi = 0;
			int numOfType = 0;
			for (long zarg = brd.getPieces(player, PieceType.BISHOP), barg = Bitboard.isolateLsb(zarg); zarg != 0L; zarg = Bitboard.extractLsb(zarg), barg = Bitboard.isolateLsb(zarg)) {// iterateOnBitIndices
				bi = Bitboard.getLowSquareIndex(barg);
				if (numOfType == 0) {
					set(SetType.BishopSet0, BitboardGen.getBishopSet(bi, brd.getOccupied()));
					set(SetType.BishopPawnSet0, augmentWithPawnAttacks(brd, player, get(SetType.BishopSet0), bi));
					long attackedQueens = get(SetType.BishopSet0) & brd.getPieces(player, PieceType.QUEEN);
					set(SetType.BishopQueenSet0, BitboardGen.getBishopSet(bi, brd.getOccupied() & ~attackedQueens) & ~get(SetType.BishopSet0));
					set(SetType.BishopQueenPawnSet0, augmentWithPawnAttacks(brd, player, get(SetType.BishopQueenSet0), bi) & ~get(SetType.BishopSet0));
					long attackedQueens2 = get(SetType.BishopQueenSet0) & brd.getPieces(player, PieceType.QUEEN);
					set(SetType.BishopQueenQueenSet0,
							BitboardGen.getBishopSet(bi, brd.getOccupied() & ~attackedQueens & ~attackedQueens2) & ~get(SetType.BishopSet0) & ~get(SetType.BishopQueenSet0));
					numOfType++;
				} else {
					set(SetType.BishopSet1, get(SetType.BishopSet0));
					set(SetType.BishopPawnSet1, get(SetType.BishopPawnSet0));
					set(SetType.BishopQueenSet1, get(SetType.BishopQueenSet0));
					set(SetType.BishopQueenPawnSet1, get(SetType.BishopQueenPawnSet0));
					set(SetType.BishopQueenQueenSet1, get(SetType.BishopQueenQueenSet0));
					
					set(SetType.BishopSet0, BitboardGen.getBishopSet(bi, brd.getOccupied()));
					set(SetType.BishopPawnSet0, augmentWithPawnAttacks(brd, player, get(SetType.BishopSet0), bi));
					long attackedQueens = get(SetType.BishopSet0) & brd.getPieces(player, PieceType.QUEEN);
					set(SetType.BishopQueenSet0, BitboardGen.getBishopSet(bi, brd.getOccupied() & ~attackedQueens) & ~get(SetType.BishopSet0));
					set(SetType.BishopQueenPawnSet0, augmentWithPawnAttacks(brd, player, get(SetType.BishopQueenSet0), bi) & ~get(SetType.BishopSet0));
					long attackedQueens2 = get(SetType.BishopQueenSet0) & brd.getPieces(player, PieceType.QUEEN);
					set(SetType.BishopQueenQueenSet0,
							BitboardGen.getBishopSet(bi, brd.getOccupied() & ~attackedQueens & ~attackedQueens2) & ~get(SetType.BishopSet0) & ~get(SetType.BishopQueenSet0));

					break;
				}
			}
		}

	}

}
